using AutoMapper;
using FluentValidation;
using MediatR;
using Stix.Contracts.Vulnerability;
using Stix.Contracts.Vulnerability.Requests;
using Stix.Contracts.Vulnerability.Responses;
using Stix.Core.Interfaces;
using Stix.Vulnerability.Models;

namespace Stix.Vulnerability.Handlers
{
    public class GetAllVulnerabilitiesHandler : IRequestHandler<GetAllVulnerabilities, GetAllVulnerabilitiesResponse>
    {
        private readonly IRepository _repository;
        private readonly IMapper _autoMapper;

        public GetAllVulnerabilitiesHandler(IRepository repository, IMapper autoMapper)
        {
            _repository = repository;
            _autoMapper = autoMapper;
        }

        public async Task<GetAllVulnerabilitiesResponse> Handle(GetAllVulnerabilities request, CancellationToken cancellationToken)
        {
            var items = await _repository.QueryAsync<VulnerabilityEntity>(q => true, request.Skip ?? 0, request.Take, s => s.id);

            return new GetAllVulnerabilitiesResponse(_autoMapper.Map<List<VulnerabilityDto>>(items));
        }
    }

    public class GetAllVulnerabilitiesValidator : AbstractValidator<GetAllVulnerabilities>
    {
        public GetAllVulnerabilitiesValidator()
        {
            RuleFor(q => q.Skip).GreaterThanOrEqualTo(0);
            RuleFor(q => q.Take).GreaterThanOrEqualTo(1).LessThanOrEqualTo(100);
        }
    }
}