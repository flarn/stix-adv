using FluentValidation;
using MediatR;
using Stix.Contracts.Vulnerability.Requests;
using Stix.Contracts.Vulnerability.Responses;
using Stix.Core;
using Stix.Core.Interfaces;
using Stix.Core.Pipeline;
using Stix.Vulnerability.Models;

namespace Stix.Vulnerability.Handlers
{
    
    public class CreateVulnerabilityHandler : IRequestHandler<CreateVulnerability, CreateVulnerabilityResponse>
    {
        private readonly IRepository _repository;

        public CreateVulnerabilityHandler(IRepository repository) => _repository = repository;

        public async Task<CreateVulnerabilityResponse> Handle(CreateVulnerability request, CancellationToken cancellationToken)
        {
            var id = IdGenerator.Generate<VulnerabilityEntity>();

            var entity = new VulnerabilityEntity(id, request.Name!)
            {
                Description = request.Description,
                Created = DateTimeOffset.UtcNow,

                Confidence = request.Confidence,
                Labels = request.Labels,
                Lang = request.Lang,
                Revoked = request.Revoked,
            };

            await _repository.Create(entity);

            return CreateVulnerabilityResponse.New(id);
        }
    }

    public class CreateVulnerabilityValidator : AbstractValidator<CreateVulnerability>
    {
        public CreateVulnerabilityValidator()
        {
            RuleFor(c => c.Name)
                .NotEmpty()
                .MaximumLength(100); //vad är rimligt?

            RuleFor(c => c.Description).MaximumLength(500).When(c => c.Description != null);
            RuleFor(c => c.Confidence).InclusiveBetween(1, 100).When(c => c.Confidence != null);
            RuleFor(c => c.Lang).Length(2).When(c => c.Lang != null);

            RuleFor(c => c.Labels).NotEmpty().When(c => c.Labels != null);
            RuleForEach(c => c.Labels).NotEmpty().MaximumLength(100).When(c => c.Labels != null);
        }
    }
}