using AutoMapper;
using FluentValidation;
using MediatR;
using Stix.Contracts.Vulnerability;
using Stix.Contracts.Vulnerability.Requests;
using Stix.Contracts.Vulnerability.Responses;
using Stix.Core;
using Stix.Core.Interfaces;
using Stix.Vulnerability.Models;

namespace Stix.Vulnerability.Handlers
{
    public class GetVulnerabilityHandler : IRequestHandler<GetVulnerability, GetVulnerabilityResponse>
    {
        private readonly IRepository _repository;
        private readonly IMapper _mapper;

        public GetVulnerabilityHandler(IRepository repository, IMapper mapper)
        {
            _repository = repository;
            _mapper = mapper;
        }

        public async Task<GetVulnerabilityResponse> Handle(GetVulnerability request, CancellationToken cancellationToken)
        {
            var item = await _repository.GetById<VulnerabilityEntity>(request.id!);

            if (item == null)
                throw new EntityNotFoundException(request.id!);

            return new GetVulnerabilityResponse(_mapper.Map<VulnerabilityDto>(item));
        }
    }

    public class GetVulnerabilityValidator : AbstractValidator<GetVulnerability>
    {
        public GetVulnerabilityValidator()
        {
            string prefix = "vulnerability--";
            RuleFor(q => q.id)
                .NotEmpty()
                .Must(m => m?.StartsWith(prefix) == true).WithMessage("id must start with 'vulnerability--'")
                .MaximumLength(prefix.Length + 36);
        }
    }
}
