using FluentValidation;
using MediatR;
using Stix.Contracts.Vulnerability.Requests;
using Stix.Contracts.Vulnerability.Responses;
using Stix.Core;
using Stix.Core.Interfaces;
using Stix.Vulnerability.Models;

namespace Stix.Vulnerability.Handlers
{
    public class DeleteVulnerabilityHandler : IRequestHandler<DeleteVulnerability, DeleteVulnerabilityResponse>
    {
        private readonly IRepository _repository;

        public DeleteVulnerabilityHandler(IRepository repository) => _repository = repository;

        public async Task<DeleteVulnerabilityResponse> Handle(DeleteVulnerability request, CancellationToken cancellationToken)
        {
            var item = await _repository.GetById<VulnerabilityEntity>(request.id!);

            //or do we care?
            if (item == null)
                throw new EntityNotFoundException(request.id!);

            await _repository.Delete<VulnerabilityEntity>(request.id!);

            return DeleteVulnerabilityResponse.Instance;
        }
    }


    public class DeleteVulnerabilityValidator : AbstractValidator<DeleteVulnerability>
    {
        public DeleteVulnerabilityValidator()
        {
            string prefix = "vulnerability--";
            RuleFor(q => q.id)
                .NotEmpty()
                .Must(m => m?.StartsWith(prefix) == true).WithMessage("id must start with 'vulnerability--'")
                .MaximumLength(prefix.Length + 36);
        }
    }
}
