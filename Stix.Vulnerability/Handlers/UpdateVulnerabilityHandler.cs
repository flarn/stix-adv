using FluentValidation;
using MediatR;
using Stix.Contracts.Vulnerability.Requests;
using Stix.Contracts.Vulnerability.Responses;
using Stix.Core;
using Stix.Core.Interfaces;
using Stix.Vulnerability.Models;

namespace Stix.Vulnerability.Handlers
{
    public class UpdateVulnerabilityHandler : IRequestHandler<UpdateVulnerability, UpdateVulnerabilityResponse>
    {
        private readonly IRepository _repository;

        public UpdateVulnerabilityHandler(IRepository repository) => _repository = repository;

        public async Task<UpdateVulnerabilityResponse> Handle(UpdateVulnerability request, CancellationToken cancellationToken)
        {
            var currentItem = await _repository.GetById<VulnerabilityEntity>(request.Id);

            if (currentItem == null)
                throw new EntityNotFoundException(request.Id);


            currentItem.Name = request.Name!;
            currentItem.Description = request.Description;
            currentItem.Confidence = request.Confidence;
            currentItem.Labels = request.Labels;
            currentItem.Revoked = request.Revoked;
            currentItem.Lang = request.Lang;
            
            currentItem.Modified = DateTimeOffset.UtcNow;


            await _repository.Replace(currentItem);

            return UpdateVulnerabilityResponse.Instance;
        }
    }

    public class UpdateVulnerabilityValidator : AbstractValidator<UpdateVulnerability>
    {
        public UpdateVulnerabilityValidator()
        {
            string prefix = "vulnerability--";
            RuleFor(q => q.Id)
                .NotEmpty()
                .Must(m => m?.StartsWith(prefix) == true).WithMessage("id must start with 'vulnerability--'")
                .MaximumLength(prefix.Length + 36);

            RuleFor(c => c.Name)
               .NotEmpty()
               .MaximumLength(100); //vad är rimligt?

            RuleFor(c => c.Description).MaximumLength(500).When(c => c.Description != null);
            RuleFor(c => c.Confidence).InclusiveBetween(1, 100).When(c => c.Confidence != null);
            RuleFor(c => c.Lang).Length(2).When(c => c.Lang != null);

            RuleFor(c => c.Labels).NotEmpty().When(c => c.Labels != null);
            RuleForEach(c => c.Labels).NotEmpty().MaximumLength(100).When(c => c.Labels != null);
        }
    }
}
